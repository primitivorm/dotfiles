###
  Atom-terminal-panel
  Copyright by isis97
  MIT licensed

  The very basic class, which handles the configuration files, loads up commands and
  answers all the commands requests generated by terminal instance.
###

{resolve, dirname, extname} = include 'path'
fs = include 'fs'

class ATPCore

  state:
    config: {}
    statePath: null
    opened: false
    customCommands: {}
    defaultCommands:
      "hello_world": {
        "description": "Prints the hello world message to the terminal output."
        "command": [
          "echo Hello world :D",
          "echo This is",
          "echo example usage",
          "echo of the console"
        ]
      }

  createDefaultCommandsFile: () ->
    if atom.config.get('atom-terminal-panel.enableUserCommands')
      try
        initialContent = {
          '_comment': 'Package atom-terminal-panel: This terminal-commands.json file was automatically generated by atom-terminal-package. It contains all useful config data.'
          commands: @state.defaultCommands
          actions: []
          toolbar: [
            ["clear", "clear", "Clears the console output."],
            ["info", "info", "Prints the terminal welcome message."],
            ["all available commands", "memdump", "Displays all available builtin commands. (all commands except native)"]
          ]
          rules: {
            "\\b[A-Z][A-Z]+\\b": {
              'match': {
                'flags': ['g']
              }
              'css': {
                'color':'gray'
              }
            }
            '(error|err):? (.*)': {
              'match': {
                'matchLine': true
                'replace': '%(label:error:text:Error) %(0)'
              }
              'css': {
                'color': 'red'
                'font-weight': 'bold'
              }
            }
            '(warning|warn|alert):? (.*)': {
              'match': {
                'matchLine': true
                'replace': '%(label:warning:text:Warning) %(0)'
              }
              'css': {
                'color': 'yellow'
              }
            }
            '(note|info):? (.*)': {
              'match': {
                'matchLine': true
                'replace': '%(label:info:text:Info) %(0)'
              }
              'css': {

              }
            }
            '(debug|dbg):? (.*)': {
              'match': {
                'matchLine': true
                'replace': '%(label:default:text:Debug) %(0)'
              }
              'css': {
                'color': 'gray'
              }
            }
          }
        }
        content = JSON.stringify initialContent, null, '\t'
        fs.writeFileSync @state.statePath, content
      catch e
        console.log 'atp-core cannot create default terminal commands JSON file', e.message

  reload: () ->
    @state.opended = false
    @init()

  init: () ->
    if not @state.opended
      @state.opened = true
      @state.statePath = dirname(atom.config.getUserConfigPath()) + '/terminal-commands.json'
      try
        @state.config = JSON.parse fs.readFileSync @state.statePath
      catch e
        console.log 'atp-core cannot reload terminal config file: invalid content', e.message
        atom.notifications.addWarning "atom-terminal-panel: Could not load the config file. The new file will be created. Reason: "+e.message
        @state.opened = no
      if not @state.opened
        @createDefaultCommandsFile()
        @state.opened = true
        @state.customCommands = @state.defaultCommands
      else
        @state.customCommands = @state.config.commands
    return this

  jsonCssToInlineStyle: (obj) ->
    if obj instanceof String
      return obj
    ret = ''
    for key, value of obj
      if key? and value?
        ret += key + ':' + value + ';'
    return ret

  getConfig: () ->
    return @state.config

  getUserCommands: () ->
    if atom.config.get('atom-terminal-panel.enableUserCommands')
      return @state.customCommands
    return null

  findUserCommandAction: (cmd) ->
    if not atom.config.get('atom-terminal-panel.enableUserCommands')
      return null
    for name, code of @state.customCommands
      if name == cmd
        if code.command?
          return code.command
        return code
    return null

  findUserCommand: (cmd) ->
    if not atom.config.get('atom-terminal-panel.enableUserCommands')
      return null
    action = @findUserCommandAction(cmd)
    if not action?
      return null
    return (state, args) ->
      return state.execDelayedCommand 1, action, args, state

module.exports = new ATPCore().init()
